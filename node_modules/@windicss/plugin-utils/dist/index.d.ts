import * as windicss_types_interfaces from 'windicss/types/interfaces';
import { FullConfig, Extractor, ExtractorResultDetailed, Config } from 'windicss/types/interfaces';
export { FullConfig as WindiCssOptions } from 'windicss/types/interfaces';
import { generateCompletions } from 'windicss/utils';
import Processor from 'windicss';
import * as magic_string from 'magic-string';

declare const defaultConfigureFiles: string[];
declare const defaultAlias: Record<string, TagNames>;
declare const preflightTags: string[];
declare const htmlTags: readonly ["html", "body", "div", "a", "abbr", "address", "area", "article", "aside", "audio", "base", "basefont", "bdo", "blink", "blockquote", "br", "button", "canvas", "caption", "center", "col", "colgroup", "command", "comment", "datalist", "dd", "del", "details", "dir", "dl", "dt", "embed", "fieldset", "figure", "b", "big", "i", "small", "tt", "font", "footer", "form", "frame", "frameset", "head", "header", "hgroup", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "isindex", "iframe", "ilayer", "img", "input", "ins", "keygen", "keygen", "label", "layer", "legend", "li", "link", "map", "mark", "marquee", "menu", "meta", "meter", "multicol", "nav", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "cite", "code", "dfn", "em", "kbd", "samp", "strong", "var", "plaintext", "pre", "progress", "q", "ruby", "script", "section", "select", "spacer", "span", "s", "strike", "style", "sub", "sup", "svg", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "u", "ul", "video", "wbr", "wbr", "xmp"];
declare type TagNames = (typeof htmlTags)[number];

declare function defineConfig(config: FullConfig): FullConfig;

interface TransformerOptions {
    include?: RegExp[];
}
declare type TransformerFunction = (code: string, id: string) => string | undefined | null;
declare type Transformer<T extends TransformerOptions> = (options?: T) => TransformerFunction;

interface HookOptions {
    matcher?: (code: string) => boolean;
    ignoreNodeModules?: boolean;
}

interface UserOptions {
    /**
     * Options for windicss/tailwindcss.
     * Also accepts string as config file path.
     *
     * @default auto searching for `windi.config.ts` / `tailwind.config.js`
     */
    config?: FullConfig | string;
    /**
     * A list of filename of paths to search of config files
     */
    configFiles?: string[];
    /**
     * Safe class names to be always included.
     *
     * @deprecated define this field in the windicss.config.ts instead
     */
    safelist?: string | (string | string[])[];
    /**
     * Class names to be always excluded.
     *
     * @deprecated define this field in the windicss.config.ts instead
     */
    blocklist?: string | (string | string[])[];
    /**
     * Enabled windicss preflight (a.k.a TailwindCSS style reset)
     *
     * @deprecated define this field in the windicss.config.ts instead
     * @default true
     */
    preflight?: boolean | {
        /**
         * Enable all the preflight regardless the template
         *
         * @deprecated define this field in the windicss.config.ts instead
         */
        enableAll?: boolean;
        /**
         * Enable all the preflight regardless the template
         *
         * @deprecated define this field in the windicss.config.ts instead
         */
        includeAll?: boolean;
        /**
         * Safelist to always included
         *
         * @deprecated define this field in the windicss.config.ts instead
         */
        safelist?: string | (string | string[])[];
        /**
         * Blocklist to always excluded
         *
         * @deprecated define this field in the windicss.config.ts instead
         */
        blocklist?: string | (string | string[])[];
        /**
          * Alias for resolving preflight
          */
        alias?: Record<string, TagNames>;
        /**
         * @default true
         * @deprecated define this field in the windicss.config.ts instead
         */
        includeBase?: boolean;
        /**
         * @default true
         * @deprecated define this field in the windicss.config.ts instead
         */
        includeGlobal?: boolean;
        /**
         * @default true
         * @deprecated define this field in the windicss.config.ts instead
         */
        includePlugin?: boolean;
    };
    /**
      * File paths will be resolved against this directory.
      *
      * @default process.cwd
      * @internal
      */
    root?: string;
    /**
     * Scan the files and extract the usage
     *
     * @default true
     */
    scan?: boolean | {
        /**
         * Auto scan on startup
         *
         * @default true
         */
        runOnStartup?: boolean;
        /**
         * Directories to search for classnames
         *
         * @default 'src'
         * @deprecated use `extract.include` in the windicss.config.ts instead
         */
        dirs?: string | string[];
        /**
         * File extension to search for classnames
         *
         * @default 'html', 'vue', 'md', 'mdx', 'pug', 'jsx', 'tsx', 'svelte', 'js', 'ts'
         * @deprecated use `extract.include` in the windicss.config.ts instead
         */
        fileExtensions?: string | string[];
        /**
         * Exclude globs
         *
         * @default []
         */
        exclude?: string | string[];
        /**
         * Include globs
         *
         * @default []
         */
        include?: string | string[];
        /**
         * Transformers to apply before doing extraction
         *
         * @default []
         */
        transformers?: TransformerFunction[];
    };
    /**
     * Transform CSS for `@apply` directive
     *
     * @default true
     */
    transformCSS?: boolean | 'pre' | 'post';
    /**
     * Transform groups like `hover:(bg-gray-100 font-medium)`
     *
     * @default true
     */
    transformGroups?: boolean;
    /**
     * Sort the genrate utilities
     *
     * @default true
     */
    sortUtilities?: boolean;
    /**
     * Callback before classes css generated
     */
    onBeforeGenerate?: (ctx: {
        classesPending: Set<string>;
        tagsPending: Set<string>;
    }) => void;
    /**
     * Callback when classes and/or tags are generated/changed
     */
    onGenerated?: (ctx: {
        classes: Set<string>;
        tags: Set<string>;
    }) => void;
    /**
     * Callback when the options are resolved. These are the plugin options and contain the windi config
     */
    onOptionsResolved?: (options: ResolvedOptions) => ResolvedOptions | void | Promise<ResolvedOptions | void>;
    /**
     * Callback when the windi config is resolved. Not to be confused with the options which are the top level way to
     * configure the util package
     */
    onConfigResolved?: (config: FullConfig, configFilePath?: string) => FullConfig | void | Promise<FullConfig | void>;
    /**
     * Callback when the utils is initialized
     */
    onInitialized?: (utils: WindiPluginUtils) => void;
}
interface LoadConfigurationOptions {
    /**
     * Name for debug
     *
     * @default 'windi-plugin-utils'
     * @internal
     */
    name?: string;
    /**
     * Use sucrase/register to load configs in ESM/TypeScript
     *
     * @default true
     */
    enableSucrase?: boolean;
    /**
     * Options for https://github.com/ariporad/pirates
     */
    hookOptions?: HookOptions;
    /**
     * Config object or path
     */
    config?: FullConfig | string;
    /**
     * CWD
     *
     * @default process.cwd
     * @internal
     */
    root?: string;
    /**
     * A list of filename of paths to search of config files
     */
    configFiles?: string[];
    /**
     * On loading configuration error
     */
    onConfigurationError?: (error: Error) => void;
}
declare type WindiPluginUtilsOptions = Omit<LoadConfigurationOptions, 'config' | 'configFiles'>;
interface ResolvedOptions {
    config: FullConfig;
    configFilePath: string | undefined;
    enableScan: boolean;
    enablePreflight: boolean;
    transformCSS: boolean | 'pre' | 'auto' | 'post';
    transformGroups: boolean;
    scanOptions: {
        fileExtensions: string[];
        dirs: string[];
        exclude: string[];
        include: string[];
        runOnStartup: boolean;
        transformers: TransformerFunction[];
        extractors: Extractor[];
    };
    preflightOptions: {
        includeBase: boolean;
        includeGlobal: boolean;
        includePlugin: boolean;
        includeAll: boolean;
        /**
         * @deprecated use includeAll
         */
        enableAll: boolean;
        safelist: Set<string>;
        blocklist: Set<string>;
        alias: Record<string, string>;
    };
    root: string;
    sortUtilities: boolean;
    safelist: Set<string>;
    blocklist: Set<string>;
    onBeforeGenerate: UserOptions['onBeforeGenerate'];
    onGenerated: UserOptions['onGenerated'];
    onConfigResolved: UserOptions['onConfigResolved'];
    onOptionsResolved: UserOptions['onOptionsResolved'];
    onInitialized: UserOptions['onInitialized'];
}

declare type Arrayable<T> = T | T[];
declare type NestedArrayable<T> = T | (T | T[])[];
declare function toArray<T>(v: Arrayable<T>): T[];
declare function flattenArray<T>(v: NestedArrayable<T>): T[];
declare function mergeArrays<T>(...args: (NestedArrayable<T> | undefined)[]): T[];
declare function slash(str: string): string;
declare function kebabCase(str: string): string;
declare function partition<T>(array: T[], filter: (i: T, idx: number, arr: T[]) => any): T[][];
declare function include<T>(set: Set<T>, v: T[] | Set<T>): void;
declare function exclude<T>(set: Set<T>, v: T[] | Set<T>): void;
declare function transformGroups(str: string): string;
declare function transformGroupsWithSourcemap(code: string): {
    code: string;
    map: magic_string.SourceMap;
} | null;

declare type CompletionsResult = ReturnType<typeof generateCompletions>;
declare type LayerName = 'base' | 'utilities' | 'components';
declare const SupportedLayers: readonly ["base", "utilities", "components"];
interface LayerMeta {
    cssCache?: string;
    timestamp?: number;
}
declare function createUtils(userOptions?: UserOptions | ResolvedOptions, utilsOptions?: WindiPluginUtilsOptions): {
    init: () => Promise<Processor>;
    ensureInit: () => Promise<Processor>;
    extractFile: (code: string, id?: string | undefined, applyGroupTransform?: boolean) => Promise<boolean>;
    applyExtractors: (code: string, id?: string | undefined) => Promise<windicss_types_interfaces.ExtractorResultDetailed>;
    generateCSS: (layer?: LayerName | undefined) => Promise<string>;
    getFiles: () => Promise<string[]>;
    clearCache: (clearAll?: boolean) => void;
    transformCSS: (css: string, id: string, transformOptions?: {
        onLayerUpdated?: (() => void) | undefined;
    } | undefined) => string;
    transformGroups: typeof transformGroups;
    transformGroupsWithSourcemap: typeof transformGroupsWithSourcemap;
    buildPendingStyles: () => void;
    isDetectTarget: (id: string) => boolean;
    isScanTarget: (id: string) => boolean;
    isCssTransformTarget: (id: string) => boolean;
    isExcluded: (id: string) => boolean;
    scan: () => Promise<void>;
    classesGenerated: Set<string>;
    classesPending: Set<string>;
    tagsGenerated: Set<string>;
    tagsPending: Set<string>;
    tagsAvailable: Set<string>;
    layersMeta: Record<LayerName, LayerMeta>;
    addClasses: (classes: string[]) => boolean;
    addTags: (tags: string[]) => boolean;
    getCompletions: () => {
        static: string[];
        color: string[];
        dynamic: string[];
    };
    readonly initialized: boolean;
    readonly options: ResolvedOptions;
    readonly files: string[];
    readonly globs: string[];
    readonly processor: Processor;
    readonly scanned: boolean;
    readonly configFilePath: string | undefined;
    readonly hasPending: boolean;
};
declare type WindiPluginUtils = ReturnType<typeof createUtils>;

declare function DefaultExtractor(code: string, id?: string): ExtractorResultDetailed;

declare function getDefaultExtractors(): Extractor[];
declare function applyExtractors(code: string, id?: string, extractors?: Extractor[], defaultExtract?: typeof DefaultExtractor): Promise<windicss_types_interfaces.ExtractorResultDetailed>;

declare function PugExtractor(code: string, id?: string): ExtractorResultDetailed;

declare function isResolvedOptions(options: UserOptions | ResolvedOptions): options is ResolvedOptions;
declare function resolveOptions(options?: UserOptions | ResolvedOptions, utilsOptions?: WindiPluginUtilsOptions, loadConfigFile?: boolean): Promise<ResolvedOptions>;
declare function loadConfiguration(options: LoadConfigurationOptions): Promise<{
    error: Error | undefined;
    resolved: FullConfig;
    configFilePath: string | undefined;
}>;

declare function mergeWindicssConfig(a: Config, b: Config): any;

export { Arrayable, CompletionsResult, DefaultExtractor, LayerMeta, LayerName, LoadConfigurationOptions, NestedArrayable, PugExtractor, ResolvedOptions, SupportedLayers, TagNames, Transformer, TransformerFunction, TransformerOptions, UserOptions, WindiPluginUtils, WindiPluginUtilsOptions, applyExtractors, createUtils, defaultAlias, defaultConfigureFiles, defineConfig, exclude, flattenArray, getDefaultExtractors, htmlTags, include, isResolvedOptions, kebabCase, loadConfiguration, mergeArrays, mergeWindicssConfig, partition, preflightTags, resolveOptions, slash, toArray, transformGroups, transformGroupsWithSourcemap };
