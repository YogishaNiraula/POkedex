var __defProp = Object.defineProperty;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __objSpread = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/constants.ts
var defaultConfigureFiles = [
  "windi.config.ts",
  "windi.config.js",
  "windi.config.mjs",
  "windi.config.cjs",
  "windicss.config.ts",
  "windicss.config.js",
  "windicss.config.mjs",
  "windicss.config.cjs",
  "tailwind.config.ts",
  "tailwind.config.js",
  "tailwind.config.mjs",
  "tailwind.config.cjs"
];
var defaultAlias = {
  "router-link": "a"
};
var preflightTags = ["html", "body", "div"];
var htmlTags = [
  "html",
  "body",
  "div",
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "base",
  "basefont",
  "bdo",
  "blink",
  "blockquote",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "col",
  "colgroup",
  "command",
  "comment",
  "datalist",
  "dd",
  "del",
  "details",
  "dir",
  "dl",
  "dt",
  "embed",
  "fieldset",
  "figure",
  "b",
  "big",
  "i",
  "small",
  "tt",
  "font",
  "footer",
  "form",
  "frame",
  "frameset",
  "head",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "isindex",
  "iframe",
  "ilayer",
  "img",
  "input",
  "ins",
  "keygen",
  "keygen",
  "label",
  "layer",
  "legend",
  "li",
  "link",
  "map",
  "mark",
  "marquee",
  "menu",
  "meta",
  "meter",
  "multicol",
  "nav",
  "nobr",
  "noembed",
  "noframes",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "cite",
  "code",
  "dfn",
  "em",
  "kbd",
  "samp",
  "strong",
  "var",
  "plaintext",
  "pre",
  "progress",
  "q",
  "ruby",
  "script",
  "section",
  "select",
  "spacer",
  "span",
  "s",
  "strike",
  "style",
  "sub",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "u",
  "ul",
  "video",
  "wbr",
  "wbr",
  "xmp"
];

// src/defineConfig.ts
function defineConfig(config) {
  return config;
}

// src/createUtils.ts
import {promises as fs2} from "fs";
import {StyleSheet} from "windicss/utils/style";
import {CSSParser} from "windicss/utils/parser";
import {generateCompletions} from "windicss/utils";
import fg from "fast-glob";
import _debug2 from "debug";
import micromatch from "micromatch";
import Processor from "windicss";

// src/resolveOptions.ts
import {existsSync, promises as fs} from "fs";
import {resolve, posix} from "path";
import {pathToFileURL} from "url";
import _debug from "debug";

// src/utils.ts
import MagicString from "magic-string";

// src/regexes.ts
var regexQuotedString = /(["'`])((?:\\\1|(?:(?!\1)|\n|\r).)*?)\1/mg;
var regexHtmlTag = /<(\w[\w-]*)[\S\s]*?\/?>/mg;
var regexClassSplitter = /[\s'"`{}]/g;
var regexClassGroup = /([!\w+-<@][\w+:_/-]*?\w):\(([!\w\s:/\\,%#\[\].$-]*?)\)/gm;
var regexClassCheck1 = /^[!a-z\d@<>.+-](?:\([\w,.%#-]*\)|[\w:/\\,%#\[\].$-])*$/;
var regexClassCheck2 = /[a-z].*[\w)\]]$/;
var regexClassChecks = [
  regexClassCheck1,
  regexClassCheck2
];
function validClassName(i) {
  return regexClassChecks.every((r) => i.match(r));
}

// src/utils.ts
function toArray(v) {
  if (Array.isArray(v))
    return v;
  return [v];
}
function flattenArray(v) {
  return toArray(v).flat();
}
function mergeArrays(...args) {
  return args.flatMap((i) => flattenArray(i || []));
}
function slash(str) {
  return str.replace(/\\/g, "/");
}
function kebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function partition(array, filter) {
  const pass = [];
  const fail = [];
  array.forEach((e, idx, arr) => (filter(e, idx, arr) ? pass : fail).push(e));
  return [pass, fail];
}
function include(set, v) {
  for (const i of v)
    set.add(i);
}
function exclude(set, v) {
  for (const i of v)
    set.delete(i);
}
function transformGroups(str) {
  return str.replace(regexClassGroup, (_, a, b) => b.split(/\s/g).map((i) => `${a}:${i}`).join(" "));
}
function transformGroupsWithSourcemap(code) {
  const s = new MagicString(code);
  let hasReplaced = false;
  let match;
  regexClassGroup.lastIndex = 0;
  while (match = regexClassGroup.exec(code)) {
    hasReplaced = true;
    const start = match.index;
    const end = start + match[0].length;
    const a = match[1];
    const b = match[2];
    const replacement = b.split(/\s/g).map((i) => `${a}:${i}`).join(" ");
    s.overwrite(start, end, replacement);
  }
  if (!hasReplaced)
    return null;
  return {
    code: s.toString(),
    map: s.generateMap({hires: true})
  };
}

// src/register.ts
import {
  addHook
} from "pirates";
import {transform} from "sucrase";
function addHook2(extension, options, hookOptions) {
  return addHook((code, filePath) => {
    const {code: transformedCode, sourceMap} = transform(code, __objSpread(__objSpread({}, options), {
      sourceMapOptions: {compiledFilename: filePath},
      filePath
    }));
    const mapBase64 = Buffer.from(JSON.stringify(sourceMap)).toString("base64");
    const suffix = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${mapBase64}`;
    return `${transformedCode}
${suffix}`;
  }, __objSpread(__objSpread({}, hookOptions), {exts: extension}));
}
function registerJS(hookOptions) {
  return addHook2([".js", ".cjs", ".mjs"], {transforms: ["imports"]}, hookOptions);
}
function registerTS(hookOptions) {
  return addHook2([".ts"], {transforms: ["imports", "typescript"]}, hookOptions);
}
function registerSucrase(hookOptions) {
  const reverts = [
    registerJS(hookOptions),
    registerTS(hookOptions)
  ];
  return () => reverts.forEach((fn) => fn());
}

// src/extractors/helper.ts
import {extname} from "path";

// src/extractors/default.ts
function DefaultExtractor(code, id) {
  if ((id == null ? void 0 : id.endsWith(".css")) || (id == null ? void 0 : id.endsWith(".postcss"))) {
    return {
      classes: [],
      tags: []
    };
  }
  const classes = Array.from(code.matchAll(regexQuotedString)).flatMap((m) => (m[2] || "").split(regexClassSplitter)).filter(validClassName);
  const tags = Array.from(code.matchAll(regexHtmlTag)).map((i) => i[1]);
  return {
    classes,
    tags
  };
}

// src/extractors/pug.ts
var regexTemplate = /<template.*?lang=['"]pug['"][^>]*?>\n([\s\S]*?\n)<\/template>/gm;
function PugExtractor(code, id) {
  const Pug = require("pug");
  const compile = (code2) => {
    try {
      return Pug.compile(code2, {filename: id})();
    } catch {
    }
  };
  let compiled;
  if (id && id.match(/\.vue$/)) {
    const matches = Array.from(code.matchAll(regexTemplate));
    let tail = "";
    for (const match of matches) {
      if (match && match[1])
        tail += `

${compile(match[1])}`;
    }
    if (tail)
      compiled = `${code}

${tail}`;
  } else {
    compiled = compile(code);
  }
  return DefaultExtractor(compiled || code);
}

// src/extractors/helper.ts
function getDefaultExtractors() {
  const extractors = [];
  try {
    require.resolve("pug");
    extractors.push({
      extractor: PugExtractor,
      extensions: ["vue", "pug"]
    });
  } catch (e) {
  }
  return extractors;
}
async function applyExtractors(code, id, extractors = [], defaultExtract = DefaultExtractor) {
  let ext = id ? extname(id) : "*";
  if (ext[0] === ".")
    ext = ext.slice(1);
  for (const {extractor, extensions} of extractors) {
    if (extensions.includes(ext))
      return extractor(code, id);
  }
  return defaultExtract(code, id);
}

// src/resolveOptions.ts
function isResolvedOptions(options) {
  return options.__windi_resolved;
}
function buildGlobs(dirs, fileExtensions) {
  dirs = toArray(dirs);
  const exts = toArray(fileExtensions);
  const globs = exts.length ? dirs.map((i) => posix.join(i, exts.length > 1 ? `**/*.{${exts.join(",")}}` : `**/*.${exts[0]}`)) : [];
  globs.push("index.html");
  return globs;
}
async function resolveOptions(options = {}, utilsOptions = {}, loadConfigFile = false) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (isResolvedOptions(options))
    return options;
  const {
    name = "windicss-plugin-utils"
  } = utilsOptions;
  const debugOptions = _debug(`${name}:options`);
  let {resolved: config, configFilePath} = loadConfigFile ? await loadConfiguration(__objSpread(__objSpread({}, utilsOptions), {
    root: utilsOptions.root || options.root,
    config: options.config,
    configFiles: options.configFiles
  })) : {resolved: {}, configFilePath: void 0};
  const modifiedConfigs = await ((_a = options.onConfigResolved) == null ? void 0 : _a.call(options, config, configFilePath));
  if (modifiedConfigs != null)
    config = modifiedConfigs;
  const {
    root = utilsOptions.root || process.cwd(),
    scan = true,
    preflight = true,
    transformCSS = true,
    transformGroups: transformGroups2 = true,
    sortUtilities = true
  } = options;
  const preflightOptions = Object.assign({
    includeBase: true,
    includeGlobal: true,
    includePlugin: true,
    enableAll: false,
    includeAll: false,
    safelist: [],
    blocklist: [],
    alias: {}
  }, typeof config.preflight === "boolean" ? {} : config.preflight, typeof preflight === "boolean" ? {} : preflight);
  preflightOptions.includeAll = preflightOptions.includeAll || preflightOptions.enableAll;
  const scanOptions = Object.assign({
    fileExtensions: ["html", "vue", "md", "mdx", "pug", "jsx", "tsx", "svelte", "ts", "js", "css", "postcss"],
    dirs: ["src"],
    exclude: [],
    include: [],
    runOnStartup: true,
    transformers: [],
    extractors: []
  }, typeof scan === "boolean" ? {} : scan);
  scanOptions.exclude = mergeArrays((_b = config.extract) == null ? void 0 : _b.exclude, scanOptions.exclude, ((_c = config.extract) == null ? void 0 : _c.exclude) ? [] : ["node_modules", ".git"]).map((i) => slash(resolve(root, i)));
  scanOptions.include = mergeArrays((_d = config.extract) == null ? void 0 : _d.include, scanOptions.include, ((_e = config.extract) == null ? void 0 : _e.include) ? [] : buildGlobs(scanOptions.dirs, scanOptions.fileExtensions)).map((i) => slash(resolve(root, i)));
  scanOptions.extractors = mergeArrays(getDefaultExtractors(), (_f = config.extract) == null ? void 0 : _f.extractors);
  const safelist = new Set(mergeArrays(config.safelist, options.safelist).flatMap((i) => i.split(" ")));
  const blocklist = new Set(mergeArrays(config.blocklist, options.blocklist).flatMap((i) => i.split(" ")));
  const configPreflightOptions = typeof config.preflight === "boolean" ? {} : config.preflight || {};
  preflightOptions.safelist = new Set(mergeArrays(configPreflightOptions == null ? void 0 : configPreflightOptions.safelist, Array.from(preflightOptions.safelist)).flatMap((i) => i.split(" ")).map((i) => {
    var _a2;
    const match = (_a2 = i.match(/^\[(.*?)\]$/)) == null ? void 0 : _a2[1];
    if (match)
      return `div ${match}`;
    return i;
  }));
  preflightOptions.blocklist = new Set(mergeArrays(configPreflightOptions == null ? void 0 : configPreflightOptions.blocklist, Array.from(preflightOptions.blocklist)).flatMap((i) => i.split(" ")));
  preflightOptions.alias = Object.fromEntries(Object.entries(__objSpread(__objSpread(__objSpread({}, defaultAlias), configPreflightOptions.alias), preflightOptions.alias)).filter(([k, v]) => [kebabCase(k), v]));
  let resolvedOptions = __objSpread(__objSpread({}, options), {
    root,
    config,
    configFilePath,
    enableScan: Boolean(scan),
    scanOptions,
    enablePreflight: config.preflight !== false && Boolean(preflight),
    preflightOptions,
    transformCSS,
    transformGroups: transformGroups2,
    sortUtilities,
    safelist,
    blocklist,
    __windi_resolved: true
  });
  const modifiedOptions = await ((_g = resolvedOptions.onOptionsResolved) == null ? void 0 : _g.call(resolvedOptions, resolvedOptions));
  if (modifiedOptions != null && modifiedOptions !== resolvedOptions)
    resolvedOptions = Object.assign(resolvedOptions, modifiedOptions);
  debugOptions(resolvedOptions);
  return resolvedOptions;
}
async function loadConfiguration(options) {
  var _a;
  let resolved = {};
  let configFilePath;
  let error;
  const {
    name = "windicss-plugin-utils",
    enableSucrase = true,
    config,
    root = process.cwd(),
    configFiles: configureFiles = defaultConfigureFiles,
    onConfigurationError = (e) => console.error(e),
    hookOptions
  } = options;
  const debugConfig = _debug(`${name}:config`);
  if (typeof config === "string" || !config) {
    if (!config) {
      for (const name2 of configureFiles) {
        const tryPath = resolve(root, name2);
        if (existsSync(tryPath)) {
          configFilePath = tryPath;
          break;
        }
      }
    } else {
      configFilePath = resolve(root, config);
      if (!existsSync(configFilePath)) {
        console.warn(`[${name}] config file "${config}" not found, ignored`);
        configFilePath = void 0;
      }
    }
    if (configFilePath) {
      let revert = () => {
      };
      try {
        debugConfig("loading from ", configFilePath);
        const isEsmJS = configFilePath.endsWith(".js") && (await fs.readFile(configFilePath, "utf-8")).includes("export default ");
        if (enableSucrase)
          revert = registerSucrase(hookOptions);
        if (isEsmJS) {
          const _import = new Function("modulePath", "return import(modulePath)");
          if (typeof require !== "undefined")
            delete require.cache[require.resolve(configFilePath)];
          resolved = ((_a = await _import(pathToFileURL(configFilePath))) == null ? void 0 : _a.default) || {};
          if (resolved.default)
            resolved = resolved.default;
        } else {
          delete require.cache[require.resolve(configFilePath)];
          resolved = require(configFilePath);
          if (resolved.default)
            resolved = resolved.default;
        }
      } catch (e) {
        error = e;
        configFilePath = void 0;
        resolved = {};
        onConfigurationError == null ? void 0 : onConfigurationError(e);
      } finally {
        revert();
      }
    }
  } else {
    resolved = config;
  }
  debugConfig(resolved);
  return {
    error,
    resolved,
    configFilePath
  };
}

// src/createUtils.ts
var SupportedLayers = ["base", "utilities", "components"];
function createUtils(userOptions = {}, utilsOptions = {
  name: "windicss-plugin-utils"
}) {
  let options = {};
  const name = utilsOptions.name;
  const debug = {
    config: _debug2(`${name}:config`),
    debug: _debug2(`${name}:debug`),
    compile: _debug2(`${name}:compile`),
    scan: _debug2(`${name}:scan`),
    scanGlob: _debug2(`${name}:scan:glob`),
    scanTransform: _debug2(`${name}:scan:transform`),
    detectClass: _debug2(`${name}:detect:class`),
    detectTag: _debug2(`${name}:detect:tag`),
    compileLayer: _debug2(`${name}:compile:layer`)
  };
  let processor;
  let completions;
  let files = [];
  const classesGenerated = new Set();
  const classesPending = new Set();
  const tagsGenerated = new Set();
  const tagsPending = new Set();
  const attrsGenerated = new Set();
  const tagsAvailable = new Set();
  function getCompletions() {
    if (!completions)
      completions = generateCompletions(processor);
    return completions;
  }
  async function getFiles() {
    await ensureInit();
    debug.scanGlob("include", options.scanOptions.include);
    debug.scanGlob("exclude", options.scanOptions.exclude);
    const files2 = await fg(options.scanOptions.include, {
      cwd: options.root,
      ignore: options.scanOptions.exclude,
      onlyFiles: true,
      absolute: true
    });
    files2.sort();
    debug.scanGlob("files", files2);
    return files2;
  }
  let scanned = false;
  let _searching;
  async function scan() {
    await ensureInit();
    if (!_searching) {
      _searching = (async () => {
        debug.scan("started");
        files.push(...await getFiles());
        const contents = await Promise.all(files.filter((id) => isDetectTarget(id)).map(async (id) => [await fs2.readFile(id, "utf-8"), id]));
        await Promise.all(contents.map(async ([content, id]) => {
          if (isCssTransformTarget(id))
            return transformCSS(content, id);
          else
            return extractFile(content, id, true);
        }));
        scanned = true;
        debug.scan("finished");
      })();
    }
    return _searching;
  }
  function isExcluded(id) {
    return micromatch.isMatch(slash(id), options.scanOptions.exclude, {dot: true});
  }
  function isIncluded(id) {
    return micromatch.isMatch(slash(id), options.scanOptions.include);
  }
  function isDetectTarget(id) {
    if (files.includes(id) || files.includes(id.slice(0, id.indexOf("?"))))
      return true;
    id = slash(id);
    return isIncluded(id) && !isExcluded(id);
  }
  function isScanTarget(id) {
    return options.enableScan ? files.some((file) => id.startsWith(file)) : isDetectTarget(id);
  }
  function isCssTransformTarget(id) {
    if (id.match(/\.(?:postcss|scss|sass|css|stylus|less)(?:$|\?)/i) && !isExcluded(id))
      return true;
    return false;
  }
  function addClasses(classes) {
    let changed = false;
    classes.forEach((i) => {
      if (!i || classesGenerated.has(i) || classesPending.has(i) || options.blocklist.has(i))
        return;
      classesPending.add(i);
      changed = true;
    });
    return changed;
  }
  function addTags(tags) {
    let changed = false;
    tags.forEach((tag) => {
      if (!tagsAvailable.has(tag))
        tag = options.preflightOptions.alias[kebabCase(tag)];
      if (options.preflightOptions.blocklist.has(tag))
        return;
      if (tagsAvailable.has(tag) && !tagsPending.has(tag)) {
        tagsPending.add(tag);
        tagsAvailable.delete(tag);
        changed = true;
      }
    });
    return changed;
  }
  async function applyExtractors2(code, id) {
    return await applyExtractors(code, id, options.scanOptions.extractors);
  }
  async function extractFile(code, id, applyGroupTransform = true) {
    if (applyGroupTransform) {
      if (options.transformGroups)
        code = transformGroups(code);
    }
    if (id) {
      debug.scanTransform(id);
      for (const trans of options.scanOptions.transformers) {
        const result = trans(code, id);
        if (result != null)
          code = result;
      }
    }
    const {classes, tags} = await applyExtractors2(code, id);
    let changed = false;
    changed = addClasses(classes || []) || changed;
    if (options.enablePreflight || !options.preflightOptions.includeAll) {
      changed = addTags(tags || []) || changed;
    }
    if (changed) {
      debug.detectClass(classesPending);
      debug.detectTag(tagsPending);
    }
    return changed;
  }
  function transformCSS(css, id, transformOptions) {
    var _a;
    if (!options.transformCSS)
      return css;
    const style = new CSSParser(css, processor).parse();
    const [layerBlocks, blocks] = partition(style.children, (i) => i.meta.group === "layer-block" && SupportedLayers.includes(i.meta.type));
    if (layerBlocks.length) {
      updateLayers(layerBlocks, id);
      style.children = blocks;
    }
    const transformed = style.build();
    if (layerBlocks.length)
      (_a = transformOptions == null ? void 0 : transformOptions.onLayerUpdated) == null ? void 0 : _a.call(transformOptions);
    return transformed;
  }
  const layers = {
    base: {},
    utilities: {},
    components: {}
  };
  const layerStylesMap = new Map();
  function updateLayers(styles, filepath, replace = true) {
    var _a;
    const timestamp = +Date.now();
    debug.compileLayer("update", filepath);
    const changedLayers = new Set();
    styles.forEach((i) => changedLayers.add(i.meta.type));
    if (replace) {
      (_a = layerStylesMap.get(filepath)) == null ? void 0 : _a.forEach((i) => changedLayers.add(i.meta.type));
      layerStylesMap.set(filepath, styles);
    } else {
      const prevStyles = layerStylesMap.get(filepath) || [];
      layerStylesMap.set(filepath, styles.concat(prevStyles));
    }
    for (const name2 of changedLayers) {
      const layer = layers[name2];
      if (layer) {
        layer.timestamp = timestamp;
        layer.cssCache = void 0;
      }
    }
  }
  function buildLayerCss(name2) {
    var _a;
    const layer = layers[name2];
    if (layer.cssCache == null) {
      const style = new StyleSheet(Array.from(layerStylesMap.values()).flatMap((i) => i).filter((i) => i.meta.type === name2));
      style.prefixer = (_a = options.config.prefixer) != null ? _a : true;
      debug.compileLayer(name2, style.children.length);
      if (options.sortUtilities)
        style.sort();
      layer.cssCache = `/* windicss layer ${name2} */
${style.build()}`;
    }
    return layer.cssCache;
  }
  function buildPendingStyles() {
    var _a, _b;
    (_a = options.onBeforeGenerate) == null ? void 0 : _a.call(options, {
      classesPending,
      tagsPending
    });
    if (classesPending.size) {
      const result = processor.interpret(Array.from(classesPending).join(" "));
      if (result.success.length) {
        debug.compile(`compiled ${result.success.length} classes out of ${classesPending.size}`);
        debug.compile(result.success);
        updateLayers(result.styleSheet.children, "__classes", false);
        include(classesGenerated, result.success);
        classesPending.clear();
      }
    }
    if (options.enablePreflight) {
      if (options.preflightOptions.includeAll || tagsPending.size) {
        const preflightStyle = processor.preflight(options.preflightOptions.includeAll ? void 0 : Array.from(tagsPending).map((i) => `<${i}/>`).join(" "), options.preflightOptions.includeBase, options.preflightOptions.includeGlobal, options.preflightOptions.includePlugin);
        updateLayers(preflightStyle.children, "__preflights", false);
        include(tagsGenerated, tagsPending);
        tagsPending.clear();
      }
    }
    (_b = options.onGenerated) == null ? void 0 : _b.call(options, {
      classes: classesGenerated,
      tags: tagsGenerated
    });
  }
  async function generateCSS(layer) {
    await ensureInit();
    if (options.enableScan && options.scanOptions.runOnStartup)
      await scan();
    buildPendingStyles();
    return layer ? buildLayerCss(layer) : [
      buildLayerCss("base"),
      buildLayerCss("components"),
      buildLayerCss("utilities")
    ].join("\n").trim();
  }
  function clearCache(clearAll = false) {
    layers.base = {};
    layers.utilities = {};
    layers.components = {};
    completions = void 0;
    if (clearAll) {
      classesPending.clear();
      tagsPending.clear();
      tagsAvailable.clear();
    } else {
      include(classesPending, classesGenerated);
      include(tagsPending, tagsGenerated);
      include(tagsPending, preflightTags);
      include(tagsAvailable, htmlTags);
    }
    include(classesPending, options.safelist);
    include(tagsPending, options.preflightOptions.safelist);
    exclude(tagsAvailable, preflightTags);
    exclude(tagsAvailable, options.preflightOptions.safelist);
    classesGenerated.clear();
    tagsGenerated.clear();
    attrsGenerated.clear();
  }
  const utils = {
    init,
    ensureInit,
    extractFile,
    applyExtractors: applyExtractors2,
    generateCSS,
    getFiles,
    clearCache,
    transformCSS,
    transformGroups,
    transformGroupsWithSourcemap,
    buildPendingStyles,
    isDetectTarget,
    isScanTarget,
    isCssTransformTarget,
    isExcluded,
    scan,
    classesGenerated,
    classesPending,
    tagsGenerated,
    tagsPending,
    tagsAvailable,
    layersMeta: layers,
    addClasses,
    addTags,
    getCompletions,
    get initialized() {
      return !!processor;
    },
    get options() {
      return options;
    },
    get files() {
      return files;
    },
    get globs() {
      return options.scanOptions.include;
    },
    get processor() {
      return processor;
    },
    get scanned() {
      return scanned;
    },
    get configFilePath() {
      return options.configFilePath;
    },
    get hasPending() {
      return Boolean(tagsPending.size || classesPending.size);
    }
  };
  async function _init() {
    var _a;
    options = await resolveOptions(userOptions, utilsOptions, true);
    files = [];
    processor = new Processor(options.config);
    clearCache(false);
    (_a = options.onInitialized) == null ? void 0 : _a.call(options, utils);
    return processor;
  }
  let _promise_init;
  async function init() {
    _promise_init = _init();
    return _promise_init;
  }
  async function ensureInit() {
    if (processor)
      return processor;
    if (!_promise_init)
      _promise_init = _init();
    return _promise_init;
  }
  return utils;
}

// src/merge.ts
var isObject = (val) => toString.call(val) === "[object Object]";
function deepMerge(a, b, rootPath) {
  a = __objSpread({}, a);
  Object.keys(b).forEach((key) => {
    if (isObject(a[key]))
      a[key] = deepMerge(a[key], b[key], rootPath ? `${rootPath}.${key}` : key);
    else if (Array.isArray(a[key]))
      a[key] = [...a[key], ...b[key]];
    else
      a[key] = b[key];
  });
  return a;
}
function mergeWindicssConfig(a, b) {
  return deepMerge(a, b, "");
}
export {
  DefaultExtractor,
  PugExtractor,
  SupportedLayers,
  applyExtractors,
  createUtils,
  defaultAlias,
  defaultConfigureFiles,
  defineConfig,
  exclude,
  flattenArray,
  getDefaultExtractors,
  htmlTags,
  include,
  isResolvedOptions,
  kebabCase,
  loadConfiguration,
  mergeArrays,
  mergeWindicssConfig,
  partition,
  preflightTags,
  resolveOptions,
  slash,
  toArray,
  transformGroups,
  transformGroupsWithSourcemap
};
